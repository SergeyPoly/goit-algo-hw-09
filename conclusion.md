# Результати тестування:
**Сума: 113**\
Жадібний алгоритм: {50: 2, 10: 1, 2: 1, 1: 1}, Час виконання: 0.000002 сек.\
Динамічне програмування: {1: 1, 2: 1, 10: 1, 50: 2}, Час виконання: 0.000151 сек.

--------------------------------------------------
**Сума: 289**\
Жадібний алгоритм: {50: 5, 25: 1, 10: 1, 2: 2}, Час виконання: 0.000002 сек.\
Динамічне програмування: {2: 2, 10: 1, 25: 1, 50: 5}, Час виконання: 0.000252 сек.

--------------------------------------------------
**Сума: 567**\
Жадібний алгоритм: {50: 11, 10: 1, 5: 1, 2: 1}, Час виконання: 0.000002 сек.\
Динамічне програмування: {2: 1, 5: 1, 10: 1, 50: 11}, Час виконання: 0.000464 сек.

--------------------------------------------------
**Сума: 1000**\
Жадібний алгоритм: {50: 20}, Час виконання: 0.000002 сек.\
Динамічне програмування: {50: 20}, Час виконання: 0.000676 сек.

--------------------------------------------------
**Сума: 3582**\
Жадібний алгоритм: {50: 71, 25: 1, 5: 1, 2: 1}, Час виконання: 0.000002 сек.\
Динамічне програмування: {2: 1, 5: 1, 25: 1, 50: 71}, Час виконання: 0.004412 сек.


# Висновки:
Під час тестування стає очевидним, що чим більша сума, тим більше часу необхідно алгоритму динамічного програмування на обробку даних і отримання результату, натомість продуктивність жадібного алгоритму є набагато меншою і сталою.\
Такі результат можна пояснити тим, що:\
**Жадібний алгоритм**, вибираючи найкращий локальний варіант має складність $O(n)$ (за умови відсутності необхідності попереднього сортування, інакше $O(n \log n)$ ), за рахунок чого працює дуже швидко, проте не завжди дає оптимальне рішення.\
**Динамічне програмування** використовує метод розв'язання складних задач шляхом розбиття їх на простіші підзадачі плюс таблицю мемоїзації, за рахунок чого має складність $O(nm)$ (m в даному прикладі, це — кількість номіналів), він програє по продуктивності жадібному алгоритму, проте може знайти оптимальніше рішення, тому є більш універсальним.